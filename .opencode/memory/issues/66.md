# ACTIVE MEMORY: Issue #66
## Link
https://github.com/huypham37/PDFScribe/issues/66

## Description
Display agent tool calls (web search, code execution, file reads, sub-agent delegations) as a list of animated progress bars showing the status of each tool execution.

## Design Reference (from screenshot)
- **Header**: "Agent Working..." with elapsed time (e.g., "4.2s elapsed")
- **Tool list**: Each tool shows:
  - Icon representing tool type (ðŸ” search, ðŸ‘¨â€ðŸ’» code, ðŸ’¾ database, ðŸŒ web)
  - Animated progress bar (different colors per tool)
  - Status: "Complete" / "Running..." / "Queued"
- **States**:
  - **Complete**: Full progress bar (blue/green) + checkmark + "Complete"
  - **Running**: Animated progress bar (purple) filling left-to-right + "Running..."
  - **Queued**: Empty gray bar + "Queued"

## Current State
- `AIViewModel` tracks `toolCalls: [ToolCall]`
- `ToolCall` model exists with name, status, timestamp
- No UI component to display them

## Tasks
- [ ] Create ToolCallView component showing tool execution list
- [ ] Implement progress bar animations for each tool
- [ ] Map tool names to icons (search, code, database, web, etc.)
- [ ] Add elapsed time counter
- [ ] Color code by tool type (blue, green, purple)
- [ ] Integrate into ReportView below AI responses
- [ ] Test with real OpenCode tool executions

## Priority
Medium

## Related
Part of premium editorial interface (Issue #49)

## Progress Log

### [2026-01-11 18:30] Session Checkpoint - Planning and Design Phase
- **Work**: Analyzed ACP protocol schema and designed two-phase tool call display system
    - **Investigation**: 
        - Examined `OpenCodeStrategy.handleNotification()` to understand ACP tool call schema
        - Tool calls send: `toolCallId`, `title` (tool name like "read", "bash"), `kind` (query/path), `rawInput` (additional params)
        - Tool updates send: `toolCallId`, `status` (pending/in_progress/completed/failed/cancelled)
        - Current `ToolCall` model has: `id`, `title`, `status` (basic structure)
    - **Design Decisions**:
        - **Two-phase UI pattern** (inspired by user's React reference):
            1. **During Execution**: Single "spotlight" card showing current tool only with slide animations
            2. **After Completion**: Collapsible timeline/tree view (collapsed â†’ timeline â†’ tree modes)
        - **Model Extensions Needed**:
            - Add `toolType: ToolType` enum (search, code, file, web, delegate, unknown)
            - Add `query: String` to store the action being performed
            - Add `startTime: Date` and `endTime: Date?` for per-tool timing
            - Create lookup table mapping tool names to display names, icons (SF Symbols), and colors
        - **Animation Strategy**:
            - Slide-up/fade-out for previous tool when new tool starts
            - Slide-in from bottom for new tool
            - Fade-out 1.5s after completion
            - Fixed height container to prevent layout shift
        - **Component Architecture**:
            - `ToolCallCard.swift` - Reusable card component
            - `ToolCallSpotlightView.swift` - Single card during execution with animations
            - `ToolCallTimelineView.swift` - Collapsible timeline/tree after completion (3 modes)
        - **Integration Logic**:
            - Show spotlight when `isProcessing && toolCalls.isNotEmpty`
            - Show timeline when `!isProcessing && toolCalls.count > 1` (skip if only 1 tool)
        - **Sub-agent Handling**: Currently show as single "Sub-Agent: explore" item, future will expand to nested card stack
        - **Timing Display**: Per-tool elapsed time + total execution time when multiple tools
    - **Status**: âœ… Planning complete, ready to implement
    - **Next Steps**: 
        1. Extend ToolCall model with new properties
        2. Create tool metadata lookup table
        3. Build view components with animations
        4. Update OpenCodeStrategy to capture timing data
        5. Integrate into ReportView
