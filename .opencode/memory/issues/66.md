# ACTIVE MEMORY: Issue #66
## Link
https://github.com/huypham37/PDFScribe/issues/66

## Description
Display agent tool calls (web search, code execution, file reads, sub-agent delegations) as a list of animated progress bars showing the status of each tool execution.

## Design Reference (from screenshot)
- **Header**: "Agent Working..." with elapsed time (e.g., "4.2s elapsed")
- **Tool list**: Each tool shows:
  - Icon representing tool type (üîç search, üë®‚Äçüíª code, üíæ database, üåê web)
  - Animated progress bar (different colors per tool)
  - Status: "Complete" / "Running..." / "Queued"
- **States**:
  - **Complete**: Full progress bar (blue/green) + checkmark + "Complete"
  - **Running**: Animated progress bar (purple) filling left-to-right + "Running..."
  - **Queued**: Empty gray bar + "Queued"

## Current State
- `AIViewModel` tracks `toolCalls: [ToolCall]`
- `ToolCall` model exists with name, status, timestamp
- No UI component to display them

## Tasks
- [ ] Create ToolCallView component showing tool execution list
- [ ] Implement progress bar animations for each tool
- [ ] Map tool names to icons (search, code, database, web, etc.)
- [ ] Add elapsed time counter
- [ ] Color code by tool type (blue, green, purple)
- [ ] Integrate into ReportView below AI responses
- [ ] Test with real OpenCode tool executions

## Priority
Medium

## Related
Part of premium editorial interface (Issue #49)

## Progress Log

### [2026-01-11 18:30] Session Checkpoint - Planning and Design Phase
- **Work**: Analyzed ACP protocol schema and designed two-phase tool call display system
    - **Investigation**: 
        - Examined `OpenCodeStrategy.handleNotification()` to understand ACP tool call schema
        - Tool calls send: `toolCallId`, `title` (tool name like "read", "bash"), `kind` (query/path), `rawInput` (additional params)
        - Tool updates send: `toolCallId`, `status` (pending/in_progress/completed/failed/cancelled)
        - Current `ToolCall` model has: `id`, `title`, `status` (basic structure)
    - **Design Decisions**:
        - **Two-phase UI pattern** (inspired by user's React reference):
            1. **During Execution**: Single "spotlight" card showing current tool only with slide animations
            2. **After Completion**: Collapsible timeline/tree view (collapsed ‚Üí timeline ‚Üí tree modes)
        - **Model Extensions Needed**:
            - Add `toolType: ToolType` enum (search, code, file, web, delegate, unknown)
            - Add `query: String` to store the action being performed
            - Add `startTime: Date` and `endTime: Date?` for per-tool timing
            - Create lookup table mapping tool names to display names, icons (SF Symbols), and colors
        - **Animation Strategy**:
            - Slide-up/fade-out for previous tool when new tool starts
            - Slide-in from bottom for new tool
            - Fade-out 1.5s after completion
            - Fixed height container to prevent layout shift
        - **Component Architecture**:
            - `ToolCallCard.swift` - Reusable card component
            - `ToolCallSpotlightView.swift` - Single card during execution with animations
            - `ToolCallTimelineView.swift` - Collapsible timeline/tree after completion (3 modes)
        - **Integration Logic**:
            - Show spotlight when `isProcessing && toolCalls.isNotEmpty`
            - Show timeline when `!isProcessing && toolCalls.count > 1` (skip if only 1 tool)
        - **Sub-agent Handling**: Currently show as single "Sub-Agent: explore" item, future will expand to nested card stack
        - **Timing Display**: Per-tool elapsed time + total execution time when multiple tools
    - **Status**: ‚úÖ Planning complete, ready to implement
    - **Next Steps**: 
        1. Extend ToolCall model with new properties
        2. Create tool metadata lookup table
        3. Build view components with animations
        4. Update OpenCodeStrategy to capture timing data
        5. Integrate into ReportView

### [2026-01-11 22:13] Session Checkpoint - Implementation Complete
- **Work**: Successfully implemented tool call animation system with ACP protocol integration
    - **Code Review and Fixes** (Commit 898882e):
        - Fixed all build errors from code review findings:
            - Replaced iOS `Color(.system*)` with macOS `Color(nsColor: .*)` throughout ToolCallCard and ToolCallTimelineView
            - Simplified ToolCallSpotlightView body by extracting helper methods to resolve Swift type-checking errors
            - Fixed `.scale()` transition syntax to `.scale(scale: 0.95)`
        - Consolidated redundant status enum: removed `.pending` and `.inProgress`, kept only `.running/.completed/.failed/.cancelled`
        - Removed unused legacy `ToolCall` initializer
        - Added `toolCalls.removeAll()` at start of `sendMessage()` to clear between queries
    
    - **Model Implementation**:
        - Extended `ToolCall` model with:
            - `name`, `query`, `toolType`, `startTime`, `endTime` properties
            - `ToolType` enum: search, code, file, web, delegate, unknown
            - `toolMetaMap` lookup table mapping tool names to SF Symbol icons and colors (bash‚Üíterminal.fill‚Üípurple, read‚Üídoc.text‚Üíblue, etc.)
            - `inferToolType()` method to categorize tools
            - Added `Codable` and `Equatable` conformance for persistence
    
    - **ACP Protocol Integration** (`OpenCodeStrategy.swift`):
        - Implemented `ToolCallHandler` protocol with methods: `addToolCall()`, `updateToolCall()`, `updateToolCallTitle()`, `updateToolCallQuery()`
        - Enhanced `handleNotification()` to parse `tool_call` and `tool_call_update` events
        - **Critical Fix**: Extract query from `rawInput` dictionary instead of `kind`:
            - `rawInput.command` for bash tools
            - `rawInput.filePath` for file operations
            - `rawInput.pattern` for search tools
            - `rawInput.url` for web tools
            - Fallback to `rawInput.description`
        - Initial `tool_call` has empty `rawInput`, actual data arrives in `tool_call_update` ‚Üí implemented query update on status change
        - Added comprehensive diagnostic logging for debugging ACP notifications
        - Agent mode changed from `research-leader` to `build`
    
    - **UI Components Created**:
        - `ToolCallCard.swift` (189 lines): Reusable card with icon, name, query display, status indicator (spinner/checkmark), animated progress bar, color-coded borders
        - `ToolCallSpotlightView.swift` (93 lines): Single-card spotlight view with slide animations, shows running tool or most recent completed tool
        - `ToolCallTimelineView.swift` (403 lines): Three view modes (collapsed‚Üítimeline‚Üítree), shows elapsed times, start/end nodes in tree view
    
    - **Integration** (`ReportView.swift`):
        - Created `PremiumQuerySectionWithTools` component
        - Shows `ToolCallSpotlightView` during processing
        - Shows `ToolCallTimelineView` after completion (even for single tool)
    
    - **Per-Message Tool Call Storage Fix** (Commit f05f051):
        - **Root Cause Identified**: Global `toolCalls` array cleared on new query caused previous messages' tool displays to disappear
        - **Solution**:
            - Added `toolCalls: [ToolCall]` property to `StoredMessage` (per-message storage)
            - Renamed `AIViewModel.toolCalls` ‚Üí `currentToolCalls` (tracks only current query)
            - Save `currentToolCalls` to assistant message when streaming ends
            - Updated `PremiumQuerySectionWithTools` to use message's own `toolCalls` for completed messages
            - Updated `ToolCallSpotlightView` to reference `currentToolCalls`
        - Added `Equatable` conformance to `StoredMessage` and `ToolCall` for SwiftUI diffing
    
    - **Files Modified** (9 files, +941 lines, -39 lines):
        - `PDFScribe/Model/ToolCall.swift`: Extended model with metadata and ACP support
        - `PDFScribe/Model/ChatSession.swift`: Added `toolCalls` array to `StoredMessage`
        - `PDFScribe/Services/Strategies/OpenCodeStrategy.swift`: ACP protocol handlers and query extraction
        - `PDFScribe/ViewModel/AIViewModel.swift`: Renamed to `currentToolCalls`, added per-message save logic
        - `PDFScribe/View/Components/ReportView.swift`: Integrated tool call displays
        - `PDFScribe/View/Components/ToolCall/` (3 new files): Card, Spotlight, Timeline components
    
    - **Testing Results**:
        - ‚úÖ Tool calls display correctly during execution
        - ‚úÖ Tool displays persist for each query-answer pair
        - ‚úÖ Build succeeds without errors
        - ‚ö†Ô∏è **Known Issue**: ToolCallCard size is too visually dominant (not yet fixed per user request)
    
    - **Status**: ‚úÖ Core implementation complete and functional
    - **Next Steps**:
        1. Adjust ToolCallCard visual sizing to be less dominant
        2. Test with various tool types (read, write, glob, grep, task delegation)
        3. Polish animations and transitions
        4. Add more tool types to metadata map as discovered
